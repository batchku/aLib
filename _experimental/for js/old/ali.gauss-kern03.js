/*	simple example of a binary operator (plus) that works like typical max binops do*/sketch.default3d();sketch.gldisable("depth_test");sketch.glclearcolor(0.,0.,0,1.);sketch.glclear();// sketch prefssketch.fontsize(9);// global varables and codevar points = new Array();var pointsnum = 10;var gridsize = 20;var grid = new Array();var optclick, shiftclick, ctlclick, modclick;var closest, modx,mody,prevgridsize;var smallgrid = 5;function init(){sketch.default3d();sketch.gldisable("depth_test");sketch.glclearcolor(0.,0.,0,1.);sketch.glclear();}// for (i=0; i < gridsize; i++) {//   grid[i] = new Array()//   for (j=0; j < gridsize; j++) {//      grid[i][j] = [0.,0.];//   }// }// for (i=0; i < gridsize; i++) {//   grid[i] = new Array()//   for (j=0; j < gridsize; j++) {//      grid[i][j] = new Array(["0.","0.","0.","0."];    // R, G, B, A//   }// }/* //-----------------colors----------------------var colortable = new Array(23);colortable[0]= new Array( "255", "255", "159");colortable[1]= new Array("255", "92", "13");colortable[2]= new Array("255", "159", "9");colortable[3]= new Array("255", "222", "9");colortable[4]= new Array("225", "255", "13");colortable[5]= new Array("168", "255", "13");colortable[6]= new Array("96", "255", "15");colortable[7]= new Array("38", "255", "19");colortable[8]= new Array("21", "255", "68");colortable[9]= new Array("19", "255", "144");colortable[10]= new Array("21", "255", "206");colortable[11]= new Array("25", "255", "206");colortable[12]= new Array("21", "250", "255");colortable[13]= new Array("25", "174","255");colortable[14]= new Array("21", "113", "255");colortable[15]= new Array("21", "36", "255");colortable[16]= new Array("98", "19", "255");colortable[17]= new Array("98", "19", "255");colortable[18]= new Array("176", "19", "255");colortable[19]= new Array("253, "19", "255");colortable[20]= new Array("255", "15", "173);colortable[21]= new Array("255", "19", "91");//----------------for cleanup --------------------*/function clear(){	for (j=0; j < pointsnum; j++) {    	points_x[j] = 0;    	points_y[j] = 0;   }   pointsnum = 0;   sketch.glclear();   refresh();}function redraw(){	sketch.glclear();	draw();	refresh();	}//---------------color grid related ---------------function setgridsize(n){	 gridsize = n;	 // fillgrid();}function makegrid(n){	 grid[n]=new Array();	 for (i=0; i < gridsize; i++) {   		grid[n][i] = new Array();   		for (j=0; j < gridsize; j++) {      		grid[n][i][j] = new Array();      		// post("setting cell of grid to an array: ",n,i,j,"\n");   		}	}}function fillgrid()  // n is the id of the point whose grid we're filling in{	var colorsum,x,y,alpha;	var v = arrayfromargs(arguments);		if (v.length>0) {		for (j=0; j < v.length; j++) {			fillgridloop(v[j]);		}	}	else {		for (j=0; j < points.length; j++) {			fillgridloop(j);		}	}	}function fillgridloop(n){	for (gx=0; gx < gridsize; gx++) {      for (gy=0; gy < gridsize; gy++) {		 x=scale(gx,0,gridsize-1,-1., 1.);      	 y=scale(gy,0,gridsize-1,-1., 1.);      	 alpha=gaussian(x,y,points[n][0], points[n][1], points[n][2], points[n][3], points[n][4]);      	 grid[n][gx][gy]=new Array(x,y,points[n][5], points[n][6], points[n][7],alpha);         // post("filling up grid", n, gx, gy, "------with: ", x,y,points[n][5], points[n][6], points[n][7],alpha, "\n");      }   }}function drawgrid(n){	for (gx=0; gx < gridsize-1; gx++) {      for (gy=0; gy < gridsize-1; gy++) {      	 with (sketch) {      	    // post("Now quading from corner: ", gx, " ", gy, "\n");      	    glbegin("quads");	      	 	// post("in the grid: ",grid[n][gx][gy][0],"\n");	      	 	glcolor(grid[n][gx][gy][2],grid[n][gx][gy][3],grid[n][gx][gy][4],grid[n][gx][gy][5]);	      	 	// post("color:" , grid[gx][gy][2],grid[gx][gy][3],grid[gx][gy][4],grid[gx][gy][5], "\n");	      	 	glvertex(grid[n][gx][gy][0], grid[n][gx][gy][1], 0);	      	 	// post("vertex:" , grid[gx][gy][0], grid[gx][gy][1], "\n");	      	 	glcolor(grid[n][gx+1][gy][2],grid[n][gx+1][gy][3],grid[n][gx+1][gy][4],grid[n][gx+1][gy][5]);	      	 	glvertex(grid[n][gx+1][gy][0], grid[n][gx+1][gy][1], 0);	      	 	glcolor(grid[n][gx+1][gy+1][2],grid[n][gx+1][gy+1][3],grid[n][gx+1][gy+1][4],grid[n][gx+1][gy+1][5]);	      	 	glvertex(grid[n][gx+1][gy+1][0], grid[n][gx+1][gy+1][1], 0);	      	 	glcolor(grid[n][gx][gy+1][2],grid[n][gx][gy+1][3],grid[n][gx][gy+1][4],grid[n][gx][gy+1][5]);	      	 	glvertex(grid[n][gx][gy+1][0], grid[n][gx][gy+1][1], 0);			glend();		}      	      }   }   refresh();}function drawlabel(n){	with (sketch) {	glcolor(1., 1., 1., 1.);	moveto(points[n][0],points[n][1]);	jString = n+1; //added one to match pattr's preset numbering.	jString = jString + "";	text(jString);	}}function draw(){	var v = arrayfromargs(arguments);	sketch.glclear();	if (v.length>0) {		for (j=0; j < v.length; j++) {			// post("tryin to draw point # :", v[j],"\n");			drawgrid(v[j]);			drawlabel(v[j]);		}	} 	else {		for (j=0; j < points.length; j++) {			// post("tryin to draw point # :", j,"\n");			drawgrid(j);			drawlabel(j);				}	}		refresh();}function newpoint(){	// arguments:  	// note: in the points array the indeces are one less than what is below	//			because the point number is not stored in the points array.	//			it's implicity cuz it's the index in the points array itself.	// 0: point #	// 1: x center position	// 2: y center position	// 3: z center height (optional)	// 4: x variance (optional)	// 5: y variance (optional)	// 6: R (optional)	// 7: G (optional)	// 8: B (optional)	var v = arrayfromargs(arguments);  	n=v[0]-1;  //subtracting one to match pattr's numbering system	points[n]=new Array();		// make grid for this point	makegrid(n);		// for the provided arguments do, put them in the points array:	for (j=1; j < v.length; j++) {		points[n][j-1]=v[j];	}		// for the rest, set initial values:	for (j=v.length; j < 9; j++) {		switch (j) {			case 3: points[n][2]= 1.; //default center height			case 4: points[n][3]= .14; // 4: x variance (optional)			case 5: points[n][4]= .14; // 5: y variance (optional)			case 6: points[n][5]= 1.; // 7: R (optional)			case 7: points[n][6]= 0.; // 8: G (optional)			case 8: points[n][7]= 0.; // 9: B (optional)			}	}	fillgrid(n);			notifyclients();}function deletepoint(n){}	function place(){	points[arguments[0]][0] = arguments[1];	points[arguments[0]][1] = arguments[2];	notifyclients();}function placeone(){	place(arguments[0], arguments[1], arguments[2]);	fillgrid(arguments[0]);}function placeall(){	pointsnum = arguments.length / 2;	for (j=0; j < pointsnum; j++) {    	place(j, arguments[j*2], arguments[j*2 + 1]);   }   	draw();}function placeauto(n){	pointsnum = n;	for (j=0; j < n; j++) {    	newpoint(j, j/12-1., 0);   }	draw();}function setcolor(){	var v = arrayfromargs(arguments);	if (v.length>3) {		points[v[0]][5]=v[1];		points[v[0]][6]=v[2];		points[v[0]][7]=v[3];		}	else {		;		points[closest][5]=v[0];		points[closest][6]=v[1];		points[closest][7]=v[2];		}	notifyclients();	fillgrid();	redraw();}//-------------------------interaction-----------------function onclick (x,y,but,mod1,shift,caps,opt,mod2){	if (opt+mod1+shift>0) {		modclick =1;		// post("prevgridsize=gridsize;");		// prevgridsize=gridsize;		// gridsize=smallgrid;		// fillgrid()	}			modx=sketch.screentoworld(x,y)[0];	mody=sketch.screentoworld(x,y)[1];	closest= closestpoint(modx,mody);		// optclick=opt;	// shiftclick=shift;	// ctlclick=mod2;		}	 function ondrag (x,y,but,mod1,shift,caps,opt,mod2){	if (shift + opt + mod1 + mod2 == 0) {		lookup(sketch.screentoworld(x,y)[0], sketch.screentoworld(x,y)[1]);	}	if (shift == 1) {		if (but == 1) { //still dragging			cx=sketch.screentoworld(x,y)[0];			cy=sketch.screentoworld(x,y)[1];			// post("checking ", cx, " ", cy, "\n");			// post("calling placeone with: ", closestpoint(cx,cy),cx,cy,"/n");			placeone(closestpoint(cx,cy), cx, cy);			drawlabel(closestpoint(cx,cy));			refresh();		}						if (but == 0) { //stopped traggng		draw();		// post("does this happen?");		shiftclick=ctlclick=optclick=modclick=0;		cx=sketch.screentoworld(x,y)[0];		cy=sketch.screentoworld(x,y)[1];		closest= closestpoint(cx,cy);		}	}	if (but == 1 && modclick==1) {		modclick = 2;				} 	if (but == 0 && modclick == 2) {		modclick = 0;		// post("setting gridsize from: ",gridsize,"to: ",prevgridsize);		// gridsize = prevgridsize;		shiftclick=ctlclick=optclick=modclick=0;		fillgrid();		redraw();		} 		if (opt == 1) {		cx=sketch.screentoworld(x,y)[0];		cy=sketch.screentoworld(x,y)[1];		// post("modx: ",modx," mody: ",cy," mody: ",cx," cy: ",cy,"closest: ",closest)		points[closest][3]=points[closest][3]+scale(cx-modx,-1.,1., -.22, .22);		points[closest][4]=points[closest][4]+scale(cy-mody,-1.,1., -.22, .22);		notifyclients();		fillgrid(closest)		redraw();		if (but == 0) { //stopped traggng			postondrag;			}		}		if (mod1 == 1) {		//cx=sketch.screentoworld(x,y)[0];		cy=sketch.screentoworld(x,y)[1];		// post("modx: ",modx," mody: ",cy," mody: ",cx," cy: ",cy,"closest: ",closest)		//points[closest][2]=points[closest][2]+scale(cx-modx,-1.,1., -.15, .15);		points[closest][2]=points[closest][2]+scale(cy-mody,-1.,1., -.35, .35);		notifyclients();		fillgrid(closest)		redraw();		if (but == 0) { //stopped traggng			postondrag;		}	}		}	function postondrag(){ //stopped traggng			modclick = 0;			// post("setting gridsize from: ",gridsize,"to: ",prevgridsize);			// gridsize = prevgridsize;			shiftclick=ctlclick=optclick=modclick=0;			// fillgrid();			// redraw();}function ondblclick(x,y,but,mod1,shift,caps,opt,mod2){	cx=sketch.screentoworld(x,y)[0];	cy=sketch.screentoworld(x,y)[1];		if (shift == 0) {	// post("adding number: ", points.length);	newpoint(points.length+1,cx,cy);  //the plus 1 is to adjust for newpoint()'s adjustment for pattr's numbering	// post("now we have: ", points.length);	fillgrid(points.length-1);	redraw();	closest= closestpoint(cx,cy);	}	if (shift == 1) {	deletepoint(closestpiont(cx,cy));	}}function onresize(){	init();}	function pointsnum(n){	pointsnum = n;}	function getdistances(){	var distances = new Array(points.length);	// post("looking up ", arguments[0][0],"\n")	for (j=0; j < points.length ; j++) {    	distances[j]=Math.sqrt((points[j][0]-arguments[0])*(points[j][0]-arguments[0])+(points[j][1]-arguments[1])*(points[j][1]-arguments[1]));    }    return(distances);}function getweigths(){	var weigths = new Array();	// post("looking up ", arguments[0][0],"\n")	for (j=0; j < points.length ; j++) {    	weigths[j]=gaussian(arguments[0],arguments[1],points[j][0], points[j][1], points[j][2], points[j][3], points[j][4]);    }    return(weigths);}function lookup(){	var sum = 0.;	var weights=getweigths(arguments[0],arguments[1]);	var weightsN= new Array ();	for (j=0; j < weights.length ; j++) {    	sum = sum + weights[j];    }    for (j=0; j < weights.length ; j++) {    	weightsN[j] = 1. / sum * weights[j];    }	outlet(0, weightsN);	// sketch.glclear();	//draw;   	//sketch.moveto(arguments[0][0],arguments[0][1]);	//sketch.circle(.1);	//refresh();  	}// -------------------------------math helpers-------function scale(x,inmin, inmax,outmin,outmax){	var xout = (x-inmin)/(inmax-inmin)*(outmax-outmin)+outmin;	return xout;}function gaussian(x,y,cx,cy,cz,sigx,sigy){	var	g=cz*1/2/Math.PI/sigx/sigy*Math.exp(-1*((x-cx)*(x-cx)/2/sigx/sigx+(y-cy)*(y-cy)/2/sigy/sigy));	return g;}function maxElement(A){   max = A[0];   for (i = 1; i < A.length; i++)      max = (max < A[i])?A[i]:max; // if (max < A[i]) max = A[i];   return max;}function closestpoint(cx, cy){			var mindist = 99999999;	var minid = 0;	var distlist = getdistances(cx,cy);			for (j=0; j < distlist.length; j++) {				if (distlist[j] < mindist ) {					// post("distance from ", j, " ---> ", distlist[j], " \n");					minid = j;					mindist = distlist[j];				}			}		return(minid);		}			// -------------------for debugging--------------function print(){	var v = arrayfromargs(arguments);	post("--------\n","there are currnetly this many points: ",points.length,"\n");	if (v.length>0) {		for (j=0; j < v.length; j++) {			post("point number: ", j, "---   value: ", points[v[j]],"\n");		}	}	else {		for (j=0; j < points.length; j++) {			post("point number: ", j, "---   value: ", points[j],"\n");		}	}		}//  ------------------------------for pattr----------------------	function setvalueof(){	var frompattr=arrayfromargs(arguments);	// post("frompattr has this many items:", frompattr.length,"\n");	// post("frompattr is : ",frompattr,"\n");	n=frompattr.length/8;	// post("from pattr has this many points:", n, "\n");	points=new Array();	for (kk=0;kk< n;kk++)	{		makegrid(kk);		points[kk]=new Array();		// post("setting point number ", kk, " to value ",frompattr.slice(0,8),"\n");		points[kk]=frompattr.slice(0,8);		frompattr = frompattr.slice(8);	}		// post("number of points is now: ", points.length, "\n");		fillgrid();	redraw();}			function getvalueof(){	var topattr = new Array();	for (j=0;j<points.length; j++) {		topattr = topattr.concat(points[j]);	}	return topattr;}