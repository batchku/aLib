/*	simple example of a binary operator (plus) that works like typical max binops do*/outlets = 2;sketch.default2d();// sketch prefssketch.fontsize(9);// global varables and codevar points_x = new Array();var points_y = new Array();var upto = 0;var closest = 0;function clear(){	// for (j=0; j < upto; j++) {    	// points_x[j] = 0;    	// points_y[j] = 0;	// }   upto = 0;	points_x = new Array();	points_y = new Array();	sketch.glclear();	refresh();}function place(){	points_x[arguments[0]] = arguments[1];	points_y[arguments[0]] = arguments[2];		notifyclients();}function placeone(){	place(arguments[0], arguments[1], arguments[2]);	sketch.glclear();	drawall();	refresh();}function placeall(){	upto = arguments.length / 2;	for (j=0; j < upto; j++) {    	place(j, arguments[j*2], arguments[j*2 + 1]);   }	sketch.glclear();	drawall();	refresh();}function placeauto(n){	//upto = n;	for (j=0; j < n; j++) {    	place(j, j/12-1., 0);   }	sketch.glclear();	drawall();	refresh();}function print(n){	for (j=0; j < n; j++) {		post("point number: ", j, ", value: ", points_x[j], " ", points_y[j], ".\n");	}}function drawall(){	with (sketch) {		upto = points_x.length;		for (j=0; j < upto; j++) {			moveto(points_x[j],points_y[j]);			jString = j;			jString = jString + "";			text(jString);		}		refresh();	}}function onclick (x,y,but,mod1,shift,caps,opt,mod2){	if (opt+mod1+shift>0) {		modclick =1;		// post("prevgridsize=gridsize;");		// prevgridsize=gridsize;		// gridsize=smallgrid;		// fillgrid()	}			var modx=sketch.screentoworld(x,y)[0];	var mody=sketch.screentoworld(x,y)[1];	closest= closestpoint(modx,mody);		// optclick=opt;	// shiftclick=shift;	// ctlclick=mod2;		}function ondrag (x,y,but,mod1,shift,caps,opt,mod2){	if (shift == 0) {	lookup(sketch.screentoworld(x,y)[0],sketch.screentoworld(x,y)[1]);	}	if (shift == 1) {		cx=sketch.screentoworld(x,y)[0];		cy=sketch.screentoworld(x,y)[1];	/*	// post("checking ", cx, " ", cy, "\n");		distlist = getdistances(cx,cy);		for (j=0; j < distlist.length; j++) {			if (distlist[j] < mindist ) {				// post("distance from ", j, " ---> ", distlist[j], " \n");				minid = j;				mindist = distlist[j];			}		}	*/			placeone(closest, cx, cy);	}	notifyclients();}function upto(n){	upto = n;}	function getdistances(){	var distances = new Array(upto);	// post("looking up ", arguments[0][0],"\n")	for (j=0; j < upto ; j++) {    	distances[j]=Math.sqrt((points_x[j]-arguments[0])*(points_x[j]-arguments[0])+(points_y[j]-arguments[1])*(points_y[j]-arguments[1]));    }    return(distances);}function closestpoint(cx, cy){			var mindist = 99999999;	var minid = 0;	var distlist = getdistances(cx,cy);			for (j=0; j < distlist.length; j++) {				if (distlist[j] < mindist ) {					// post("distance from ", j, " ---> ", distlist[j], " \n");					minid = j;					mindist = distlist[j];				}			}		return(minid);		}	function lookup(x,y){		//outlet(0,getdistances(arguments[0][0],arguments[0][1]));	outlet(0,getdistances(x,y));	// sketch.glclear();	//drawall;   	//sketch.moveto(arguments[0][0],arguments[0][1]);	//sketch.circle(.1);	//refresh();  	outlet(1,"lookup",x,y);}	function redraw(){	sketch.glclear();	drawall();	refresh();	}	function setvalueof(){	var v=arrayfromargs(arguments);		for (j=0;j<v.length/2;j++)	{	points_x[j]=v[j];	points_y[j]=v[j+v.length/2];	}	redraw();}			function getvalueof(){	return points_x.concat(points_y);}	